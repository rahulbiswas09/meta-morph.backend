"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Music = void 0;
const Client_1 = require("../api/resources/music/client/Client");
class Music extends Client_1.Music {
    constructor(options = {}) {
        super(options);
    }
    /**
     * Compose a song from a prompt or a composition plan with detailed response parsing.
     * This method calls the original composeDetailed and then parses the stream response.
     * @throws {@link ElevenLabs.UnprocessableEntityError}
     */
    // @ts-expect-error - Intentionally overriding parent method with different return type
    composeDetailed() {
        const _super = Object.create(null, {
            composeDetailed: { get: () => super.composeDetailed }
        });
        return __awaiter(this, arguments, void 0, function* (request = {}, requestOptions) {
            // Call the parent method to get the stream
            const response = yield _super.composeDetailed.call(this, request, requestOptions);
            // Parse the stream using your existing parsing method
            const parsedResponse = yield this.parseMultipart(response);
            return parsedResponse;
        });
    }
    /**
     * Reads a ReadableStream containing multipart data and parses it into JSON and audio parts
     * @param stream - ReadableStream from ElevenLabs music API response
     * @returns Object containing parsed JSON metadata, audio Buffer, and filename
     */
    parseMultipart(stream) {
        return __awaiter(this, void 0, void 0, function* () {
            // Read the stream and collect all chunks
            const reader = stream.getReader();
            const chunks = [];
            let done = false;
            while (!done) {
                const result = yield reader.read();
                done = result.done;
                if (result.value) {
                    chunks.push(result.value);
                }
            }
            // Combine all chunks into a single buffer
            const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
            const responseBytes = new Uint8Array(totalLength);
            let offset = 0;
            for (const chunk of chunks) {
                responseBytes.set(chunk, offset);
                offset += chunk.length;
            }
            // Parse the multipart content
            const responseText = new TextDecoder().decode(responseBytes);
            const lines = responseText.split('\n');
            const boundary = lines[0].trim();
            // Find the JSON part (should be early in the response)
            let jsonData = null;
            let filename = 'generated_music.mp3';
            // Parse JSON from the text representation
            for (let i = 0; i < Math.min(10, lines.length); i++) {
                if (lines[i].includes('Content-Type: application/json') && i + 2 < lines.length) {
                    const jsonLine = lines[i + 2];
                    if (jsonLine.trim() && jsonLine.startsWith('{')) {
                        try {
                            const rawJson = JSON.parse(jsonLine);
                            // Convert snake_case keys to camelCase
                            jsonData = this.toCamelCase(rawJson);
                            console.log('âœ“ Successfully parsed JSON metadata');
                        }
                        catch (e) {
                            console.warn('Failed to parse JSON:', e);
                        }
                        break;
                    }
                }
            }
            // Extract filename from headers
            for (let i = 0; i < Math.min(20, lines.length); i++) {
                if (lines[i].includes('filename=')) {
                    const match = lines[i].match(/filename="([^"]+)"/);
                    if (match) {
                        filename = match[1];
                        break;
                    }
                }
            }
            // Find where the audio data starts (after the second boundary and headers)
            const boundaryBytes = new TextEncoder().encode(boundary);
            let firstBoundary = -1;
            let secondBoundary = -1;
            for (let i = 0; i <= responseBytes.length - boundaryBytes.length; i++) {
                let match = true;
                for (let j = 0; j < boundaryBytes.length; j++) {
                    if (responseBytes[i + j] !== boundaryBytes[j]) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    if (firstBoundary === -1) {
                        firstBoundary = i;
                    }
                    else if (secondBoundary === -1) {
                        secondBoundary = i;
                        break;
                    }
                }
            }
            if (secondBoundary === -1) {
                throw new Error('Could not find audio part boundary');
            }
            // Find the start of audio data (after headers and empty line)
            let audioStart = secondBoundary + boundaryBytes.length;
            // Skip past the headers to find the empty line
            while (audioStart < responseBytes.length - 1) {
                if (responseBytes[audioStart] === 0x0A && responseBytes[audioStart + 1] === 0x0A) {
                    // Found \n\n - audio starts after this
                    audioStart += 2;
                    break;
                }
                audioStart++;
            }
            // Audio goes until the end (or until we find another boundary, but usually it's the end)
            const audioBuffer = Buffer.from(responseBytes.slice(audioStart));
            if (!jsonData) {
                throw new Error('Could not parse JSON data');
            }
            return {
                json: jsonData,
                audio: audioBuffer,
                filename: filename
            };
        });
    }
    /**
     * Converts snake_case keys to camelCase recursively
     */
    toCamelCase(obj) {
        if (Array.isArray(obj)) {
            return obj.map((item) => this.toCamelCase(item));
        }
        else if (obj !== null && typeof obj === 'object') {
            return Object.keys(obj).reduce((result, key) => {
                const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
                result[camelKey] = this.toCamelCase(obj[key]);
                return result;
            }, {});
        }
        return obj;
    }
}
exports.Music = Music;
